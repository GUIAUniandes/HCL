VM
--------
Document every file in the vm folder
Document the VM

Optimize print, read for atoms and arrays
Ompitmize printing strings with spaces
Dynamic memory allocation via set command



Compiler
--------
0. Documentation and Cleanup
1. Implement Semantic Analysis
   1.1 Expression Translation and Three-Adress Code
   1.2 Type Checking 
2. Intermediate and final Code Generation


compile_do(doblock, level):
	guards = doblock.guards

	write(buffer, level + 'do:\n')
	write(buffer, level + '\tgss ')

	guardnames = {}

	for guard in guards:
		ugname = ugn(guard, env)	;; Unused gaurd name
		guardnames[guard] = ugname
		write(buffer, ugname + ' ')

	write(buffer, '\n')
	write(buffer, level + '\tclc:\n')

	for guard in guards:
		compile(guard, level)

	for guard in guards:
		write(buffer, level + '\tact' + guardnames[guard] + ':\n')

		body = guard.body

		compile(body, level + 1)

EXPLORE:
	Compiler security (Ken thompson Turing award lecture)
	Security by I/O pocedures (gets (unbound I/O), Morris worm)
	Garbage collection (freeing unused variables in a program)

COMPILED CODE FACTORIZATION

if sum = s -> s11; s12; ..; s1n
[] sum > s -> s21; s22; ..; s2n
[] sum < s -> s31; s32; ..; s3n
fi

Let eqvsij, be que insturctions compiled for the statement sij.

The code above, should compile without optimizations to something similar to:

if:
	gss g1 g2 g3

	cmp sum s
	equ:
		mov g1 000001

	cmp sum s
	sgt:
		mov g2 000001

	cmp sum s
	slt:
		mov g3 000001

	act g1:
		eqvs11
		...
		eqvs1n

	...

An optmized version could be:

if:
	gss g1 g2 g3

	cmp sum s
	equ:
		mov g1 000001

	sgt:
		mov g2 000001

	slt:
		mov g3 000001

	act g1:
		eqvs11
		...
		eqvs1n

	...





